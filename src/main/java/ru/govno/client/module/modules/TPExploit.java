package ru.govno.client.module.modules;

import java.util.ArrayList;
import java.util.List;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.Vec3d;
import org.lwjgl.opengl.GL11;
import ru.govno.client.event.EventTarget;
import ru.govno.client.event.events.EventReceivePacket;
import ru.govno.client.module.Module;
import ru.govno.client.utils.Math.MathUtils;
import ru.govno.client.utils.Movement.MoveMeHelp;
import ru.govno.client.utils.Render.AnimationUtils;
import ru.govno.client.utils.Render.ColorUtils;
import ru.govno.client.utils.Render.RenderUtils;

public class TPExploit extends Module {
   public static TPExploit get;
   private TPExploit.AVec3d lastGround;
   private final List<TPExploit.AVec3d> AVec3ds = new ArrayList<>();

   public TPExploit() {
      super("TPExploit", 0, Module.Category.MISC);
      get = this;
   }

   @Override
   public void onToggled(boolean actived) {
      if (actived) {
         this.lastGround = new TPExploit.AVec3d(Minecraft.player.getPositionVector());
         this.stateAnim.to = 1.0F;
      } else {
         if (this.lastGround != null) {
            this.lastGround.setToRemove();
         }

         this.AVec3ds.forEach(TPExploit.AVec3d::setToRemove);
         this.stateAnim.to = 0.0F;
      }

      super.onToggled(actived);
   }

   @Override
   public void onUpdate() {
      if (this.actived) {
         this.stateAnim.to = 1.0F;
      }

      Minecraft.player.onGround = false;
      Minecraft.player.isAirBorne = true;
      if (Minecraft.player.isCollidedVertically) {
         MoveMeHelp.setSpeed(MoveMeHelp.getSpeed());
      }

      if (Minecraft.player.isSneaking() && this.lastGround != null && Minecraft.player.getDistanceToVec3d(this.lastGround.getVec()) > 0.002) {
         Entity.motiony = 0.01F;
      }

      double dx = Minecraft.player.posX - Minecraft.player.lastTickPosX;
      double dy = Minecraft.player.posY - Minecraft.player.lastTickPosY;
      double dz = Minecraft.player.posZ - Minecraft.player.lastTickPosZ;
      if (Math.sqrt(dx * dx + dy * dy + dz * dz) > 0.0) {
         this.AVec3ds.add(new TPExploit.AVec3d(Minecraft.player.getPositionVector()));
      }
   }

   @Override
   public void alwaysRender3D() {
      float alphaPC;
      if ((alphaPC = this.stateAnim.getAnim()) < 0.05F) {
         this.AVec3ds.clear();
      } else {
         if (this.stateAnim.to == 0.0F) {
            this.AVec3ds.forEach(TPExploit.AVec3d::setToRemove);
         }

         this.AVec3ds.removeIf(TPExploit.AVec3d::wantToRemove);
         RenderUtils.setup3dForBlockPos(() -> {
            GL11.glDisable(3008);
            GL11.glEnable(2832);
            GL11.glDepthMask(false);
            if (this.lastGround != null) {
               GL11.glEnable(2848);
               GL11.glHint(3154, 4354);
               GL11.glLineWidth(0.01F + 3.245F * alphaPC);
               GL11.glBegin(2);
               Vec3d vec = this.lastGround.getVec();
               double e = 0.3F;
               double x = vec.xCoord;
               double y = vec.yCoord;
               double z = vec.zCoord;
               double distance = Minecraft.player == null ? 0.0 : (double)Minecraft.player.getSmoothDistanceToCoord((float)x, (float)y, (float)z);
               float dstPCAlpha = (float)MathUtils.clamp(distance / 10.0 * (distance / 10.0), 0.0, 1.0);
               RenderUtils.glColor(ColorUtils.swapAlpha(-1, alphaPC * (0.25F + dstPCAlpha * 0.75F) * 180.0F));
               GL11.glVertex3d(x - 0.3F, y, z - 0.3F);
               GL11.glVertex3d(x + 0.3F, y, z - 0.3F);
               GL11.glVertex3d(x + 0.3F, y, z + 0.3F);
               GL11.glVertex3d(x - 0.3F, y, z + 0.3F);
               GL11.glEnd();
               GL11.glLineWidth(1.0F);
               GL11.glHint(3154, 4352);
               GL11.glDisable(2848);
            }

            if (!this.AVec3ds.isEmpty()) {
               GL11.glEnable(2848);
               GL11.glHint(3154, 4354);
               GL11.glLineWidth(0.01F + 0.75F * alphaPC);
               GL11.glBegin(3);
               this.AVec3ds.forEach(avec -> {
                  Vec3d vecx = avec.getVec();
                  boolean ground = mc.world != null && !mc.world.getCollisionBoxes(Minecraft.player, new AxisAlignedBB(vecx).offsetMinDown(0.01)).isEmpty();
                  int color = ground ? ColorUtils.getColor(255, 255, 255) : ColorUtils.getColor(255, 120, 120);
                  color = ColorUtils.swapAlpha(color, 45.0F * alphaPC * avec.getAlphaPC(true));
                  RenderUtils.glColor(color);
                  GL11.glVertex3d(vecx.xCoord, vecx.yCoord, vecx.zCoord);
               });
               GL11.glEnd();
               GL11.glLineWidth(1.0F);
               GL11.glHint(3154, 4352);
               GL11.glDisable(2848);
               GL11.glEnable(2832);
               GL11.glPointSize(0.01F + 2.0F * alphaPC);
               GL11.glBegin(0);
               this.AVec3ds.forEach(avec -> {
                  Vec3d vecx = avec.getVec();
                  boolean ground = mc.world != null && !mc.world.getCollisionBoxes(Minecraft.player, new AxisAlignedBB(vecx).offsetMinDown(0.01)).isEmpty();
                  int color = ground ? ColorUtils.getColor(255, 255, 255) : ColorUtils.getColor(255, 0, 0);
                  color = ColorUtils.swapAlpha(color, 255.0F * alphaPC * avec.getAlphaPC(false));
                  RenderUtils.glColor(color);
                  GL11.glVertex3d(vecx.xCoord, vecx.yCoord, vecx.zCoord);
               });
               GL11.glEnd();
               GL11.glPointSize(1.0F);
            }

            GL11.glPointSize(1.0F);
            GL11.glEnable(3008);
            GL11.glDepthMask(true);
         }, true);
      }
   }

   @EventTarget
   public void onReceive(EventReceivePacket event) {
      if (this.actived) {
         if (event.getPacket() instanceof SPacketPlayerPosLook look) {
            Vec3d vec = this.lastGround == null ? Vec3d.ZERO : this.lastGround.getVec();
            double x = look.getX();
            double y = look.getY();
            double z = look.getZ();
            double x2 = vec.xCoord;
            double y2 = vec.yCoord;
            double z2 = vec.zCoord;
            double dx = x - x2;
            double dy = y - y2;
            double dz = z - z2;
            this.AVec3ds.forEach(TPExploit.AVec3d::setToRemove);
            this.lastGround.setVec(new Vec3d(x, y, z));
         }
      }
   }

   private class AVec3d {
      private final AnimationUtils alphaPC = new AnimationUtils(0.0F, 1.0F, 0.025F);
      private Vec3d vec;

      public AVec3d(Vec3d vec) {
         this.vec = vec;
      }

      public void setToRemove() {
         this.alphaPC.to = 0.0F;
      }

      public boolean wantToRemove() {
         return this.alphaPC.to == 0.0F && this.getAlphaPC(false) == 0.0F;
      }

      public float getAlphaPC(boolean update) {
         float aPC = update ? this.alphaPC.getAnim() : this.alphaPC.anim;
         return (double)aPC > 0.95 ? 1.0F : ((double)aPC < 0.05 ? 0.0F : aPC);
      }

      public Vec3d getVec() {
         return this.vec;
      }

      public void setVec(Vec3d vec) {
         this.vec = vec;
      }
   }
}

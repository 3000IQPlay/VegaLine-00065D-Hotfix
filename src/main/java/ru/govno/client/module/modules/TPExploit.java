package ru.govno.client.module.modules;

import java.util.ArrayList;
import java.util.List;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.network.Packet;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.Vec3d;
import org.lwjgl.opengl.GL11;
import ru.govno.client.event.EventTarget;
import ru.govno.client.event.events.EventReceivePacket;
import ru.govno.client.module.Module;
import ru.govno.client.utils.Math.MathUtils;
import ru.govno.client.utils.Movement.MoveMeHelp;
import ru.govno.client.utils.Render.AnimationUtils;
import ru.govno.client.utils.Render.ColorUtils;
import ru.govno.client.utils.Render.RenderUtils;

public class TPExploit
extends Module {
    public static TPExploit get;
    private AVec3d lastGround;
    private final List<AVec3d> AVec3ds = new ArrayList<AVec3d>();

    public TPExploit() {
        super("TPExploit", 0, Module.Category.MISC);
        get = this;
    }

    @Override
    public void onToggled(boolean actived) {
        if (actived) {
            this.lastGround = new AVec3d(Minecraft.player.getPositionVector());
            this.stateAnim.to = 1.0f;
            this.stateAnim.speed = 0.05f;
        } else {
            if (this.lastGround != null) {
                this.lastGround.setToRemove();
            }
            this.AVec3ds.forEach(AVec3d::setToRemove);
            this.stateAnim.to = 0.0f;
            this.stateAnim.speed = 0.05f;
        }
        super.onToggled(actived);
    }

    @Override
    public void onUpdate() {
        double dz;
        double dy;
        double dx;
        if (this.actived) {
            this.stateAnim.to = 1.0f;
        }
        Minecraft.player.onGround = false;
        Minecraft.player.isAirBorne = true;
        if (Minecraft.player.isCollidedVertically) {
            MoveMeHelp.setSpeed(MoveMeHelp.getSpeed());
        }
        if (Minecraft.player.isSneaking() && this.lastGround != null && Minecraft.player.getDistanceToVec3d(this.lastGround.getVec()) > 0.002) {
            Entity.motiony = 0.01f;
        }
        if (Math.sqrt((dx = Minecraft.player.posX - Minecraft.player.lastTickPosX) * dx + (dy = Minecraft.player.posY - Minecraft.player.lastTickPosY) * dy + (dz = Minecraft.player.posZ - Minecraft.player.lastTickPosZ) * dz) > 0.0) {
            this.AVec3ds.add(new AVec3d(Minecraft.player.getPositionVector()));
        }
    }

    @Override
    public void alwaysRender3D() {
        float alphaPC;
        if ((alphaPC = this.stateAnim.getAnim()) < 0.05F) {
            this.AVec3ds.clear();
        } else {
            if (this.stateAnim.to == 0.0F) {
                this.AVec3ds.forEach(TPExploit.AVec3d::setToRemove);
            }

            this.AVec3ds.removeIf(TPExploit.AVec3d::wantToRemove);
            RenderUtils.setup3dForBlockPos(() -> {
                GL11.glDisable(3008);
                GL11.glEnable(2832);
                GL11.glDepthMask(false);
                if (this.lastGround != null) {
                    GL11.glEnable(2848);
                    GL11.glHint(3154, 4354);
                    GL11.glLineWidth(0.01F + 3.245F * alphaPC);
                    GL11.glBegin(2);
                    Vec3d vec = this.lastGround.getVec();
                    double e = 0.3F;
                    double x = vec.xCoord;
                    double y = vec.yCoord;
                    double z = vec.zCoord;
                    double distance = Minecraft.player == null ? 0.0 : (double)Minecraft.player.getSmoothDistanceToCoord((float)x, (float)y, (float)z);
                    float dstPCAlpha = (float)MathUtils.clamp(distance / 10.0 * (distance / 10.0), 0.0, 1.0);
                    RenderUtils.glColor(ColorUtils.swapAlpha(-1, alphaPC * (0.25F + dstPCAlpha * 0.75F) * 180.0F));
                    GL11.glVertex3d(x - 0.3F, y, z - 0.3F);
                    GL11.glVertex3d(x + 0.3F, y, z - 0.3F);
                    GL11.glVertex3d(x + 0.3F, y, z + 0.3F);
                    GL11.glVertex3d(x - 0.3F, y, z + 0.3F);
                    GL11.glEnd();
                    GL11.glLineWidth(1.0F);
                    GL11.glHint(3154, 4352);
                    GL11.glDisable(2848);
                }

                if (!this.AVec3ds.isEmpty()) {
                    GL11.glEnable(2848);
                    GL11.glHint(3154, 4354);
                    GL11.glLineWidth(0.01F + 0.75F * alphaPC);
                    GL11.glBegin(3);
                    this.AVec3ds.forEach(avec -> {
                        Vec3d vecx = avec.getVec();
                        boolean ground = mc.world != null && !mc.world.getCollisionBoxes(Minecraft.player, new AxisAlignedBB(vecx).offsetMinDown(0.01)).isEmpty();
                        int color = ground ? ColorUtils.getColor(255, 255, 255) : ColorUtils.getColor(255, 120, 120);
                        color = ColorUtils.swapAlpha(color, 45.0F * alphaPC * avec.getAlphaPC(true));
                        RenderUtils.glColor(color);
                        GL11.glVertex3d(vecx.xCoord, vecx.yCoord, vecx.zCoord);
                    });
                    GL11.glEnd();
                    GL11.glLineWidth(1.0F);
                    GL11.glHint(3154, 4352);
                    GL11.glDisable(2848);
                    GL11.glEnable(2832);
                    GL11.glPointSize(0.01F + 2.0F * alphaPC);
                    GL11.glBegin(0);
                    this.AVec3ds.forEach(avec -> {
                        Vec3d vecx = avec.getVec();
                        boolean ground = mc.world != null && !mc.world.getCollisionBoxes(Minecraft.player, new AxisAlignedBB(vecx).offsetMinDown(0.01)).isEmpty();
                        int color = ground ? ColorUtils.getColor(255, 255, 255) : ColorUtils.getColor(255, 0, 0);
                        color = ColorUtils.swapAlpha(color, 255.0F * alphaPC * avec.getAlphaPC(false));
                        RenderUtils.glColor(color);
                        GL11.glVertex3d(vecx.xCoord, vecx.yCoord, vecx.zCoord);
                    });
                    GL11.glEnd();
                    GL11.glPointSize(1.0F);
                }

                GL11.glPointSize(1.0F);
                GL11.glEnable(3008);
                GL11.glDepthMask(true);
            }, true);
        }
    }

    @EventTarget
    public void onReceive(EventReceivePacket event) {
        if (!this.actived) {
            return;
        }
        Packet packet = event.getPacket();
        if (packet instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook look = (SPacketPlayerPosLook)packet;
            Vec3d vec = this.lastGround == null ? Vec3d.ZERO : this.lastGround.getVec();
            double x = look.getX();
            double y = look.getY();
            double z = look.getZ();
            double x2 = vec.xCoord;
            double y2 = vec.yCoord;
            double z2 = vec.zCoord;
            double dx = x - x2;
            double dy = y - y2;
            double dz = z - z2;
            this.AVec3ds.forEach(AVec3d::setToRemove);
            this.lastGround.setVec(new Vec3d(x, y, z));
        }
    }

    private class AVec3d {
        private final AnimationUtils alphaPC = new AnimationUtils(0.0f, 1.0f, 0.025f);
        private Vec3d vec;

        public AVec3d(Vec3d vec) {
            this.vec = vec;
        }

        public void setToRemove() {
            this.alphaPC.to = 0.0f;
        }

        public boolean wantToRemove() {
            return this.alphaPC.to == 0.0f && this.getAlphaPC(false) == 0.0f;
        }

        public float getAlphaPC(boolean update) {
            float aPC;
            float f = aPC = update ? this.alphaPC.getAnim() : this.alphaPC.anim;
            return (double)aPC > 0.95 ? 1.0f : ((double)aPC < 0.05 ? 0.0f : aPC);
        }

        public Vec3d getVec() {
            return this.vec;
        }

        public void setVec(Vec3d vec) {
            this.vec = vec;
        }
    }
}

